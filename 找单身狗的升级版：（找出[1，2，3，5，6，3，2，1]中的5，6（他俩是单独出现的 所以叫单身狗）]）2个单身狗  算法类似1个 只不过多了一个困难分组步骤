===================================================================我的源码  复杂但是可以实现==========================================================
===================================================================我的源码  复杂但是可以实现==========================================================
===================================================================我的源码  复杂但是可以实现==========================================================

#define _CRT_SECURE_NO_WARNINGS 1
# include<stdio.h>
# include<stddef.h>
# include<stdlib.h>
# include<string.h>



int main()

{
	int arr[] = { -1,-1,2,2,3,3,64,0,8,8};
	int i = 0;
	int tmp = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	int* a1 = (int*)calloc(sz , sizeof(arr[0])); // 创建两个数组  到时候把两个单身狗分开来 进入两个组 最后 即可以分别通过一个单身狗“所有元素按位^ 来取得这俩单身狗 ”
	int* a2 = (int*)calloc(sz , sizeof(arr[0])); // 动态内存开辟方式 灵活开辟大小且初始化0; 
	int x = 0;
	int y = 0;
  
    //首先将原数组全按位^得到 两个单身狗^的结果 存入tmp
	for (i = 0;i<sz;i++)
	{
		tmp=tmp^arr[i];
	}
  



	for (int j = 0; j < 32; j++) //系统最多32位  所以32次内 绝对找出 tmp 第几个二进制位是 1 （这个 1 是由 俩单身狗 某一对应位 一 0 一 1 ^ 出来的）
	{
		if (((tmp >> j) & 1) == 1)//系统最多32位  所以32次内 绝对找出 tmp 第几个二进制位是 1 移动位置存入j （这个 1 是由 俩单身狗 某一对应位 一 0 一 1 ^ 出来的） 他俩第j+1位不同
		{
			for (i = 0; i < sz; i++)
			{
				if (((arr[i]>>j) & 1) == 1) //分组  把第j+1 二进制位置 为 1 的 arr 中的 数字 搞入一个床好的房间a1
				{
					a1[x] = arr[i];
					x++;                             //核心部分思想  将俩单身狗 某一位置 j+1 二进制不同的 位置找出来j+1位置  ！然后将所有元素 按  这个位置 1 or 0 分成两批  则 1批a1含有若干对情侣和狗1
				}
				else                                                                                                                                       另一批a2 则 1批含有若干对情侣和狗2
				{
					a2[y] = arr[i];   //分组  把第j+1 二进制位置 为 1 的 arr 中的 数字 搞入一个床好的房间 a2
					y++;
				}
			}
			break;
		}
		
	}
	

                                  //接下来相当于把找出一个房间中 俩单身狗 ==》转化为在房间中分别 找出 存在的一个 单身狗
	tmp = 0;                        //则各自数组房间 按位^（ 即使没有对 或者没占满但是 区域元素为0 按位^不影响) 然后分别输出即可
	for (i = 0; i < sz; i++)
	{
		tmp = tmp ^ a1[i];
	}
	printf("%d\n", tmp);
	free(a1);
	a1 = NULL;

	
	tmp = 0;
	for (i = 0; i < sz; i++)
	{
		tmp = tmp ^ a2[i];
	}
	printf("%d\n", tmp);
	
	
	free(a2);
	a2 = NULL;
}





